---
layout:       post
title:        "超详细讲解区间DP"
date:         2025-10-8
author:       "ZZJ"
header-style: text
catalog:      true
tags: 
    - DP
    - C++
    - Python
    - 算法
    - 笔记
---

### 🌰 **举个栗子：班级分组做游戏**
假设你是班长，要把**30个同学分成相邻小组**完成任务。规则：
1. 每个小组有基础得分（人数越多分越高）
2. 合并相邻小组时：得分 = 左组得分 + 右组得分 + 合并代价（比如人数乘积）
3. **目标**：找出让全班总得分最高的分组方案（即合并顺序）

> 💡 **这就是经典「石子合并」问题！**  
> - 同学 = 石子  
> - 小组得分 = 区间得分  
> - 合并方案 = 区间划分策略  

---

### 🧩 区间DP的核心四步（用班级问题理解）
#### 1️⃣ **步骤一：定义状态（给小组打分）**  
- 问题：`第3到第15个同学组成的小组，最高能得多少分？`  
- **状态设计**：`dp[3][15]` = 第3→15同学的最高得分  
  > ✅ **关键思维**：把大区间（全班）拆成小区间（小组），先解决小问题

#### 2️⃣ **步骤二：初始化（最小小组的得分）**  
- 每个同学单独成组：`dp[i][i] = 该同学的基础分`（如图中单人积木分值）  
- 相邻两人合并：`dp[i][i+1] = dp[i][i] + dp[i+1][i+1] + 合并代价`  

#### 3️⃣ **步骤三：状态转移（小组的合并策略）**  
🔍 思考：如何计算`dp[3][15]`？  
- **枚举分割点k**（从第3人到第14人）：  
  ```python
  候选方案1: dp[3][3] + dp[4][15] + cost(3,3,15)   # 让第3人单干，合并其他
  候选方案2: dp[3][4] + dp[5][15] + cost(3,4,15)   # 让3-4人成组，合并其他
  ...直到...
  候选方案12: dp[3][14] + dp[15][15] + cost(3,14,15) 
  ```
- **转移方程**：  
  `dp[i][j] = max( dp[i][k] + dp[k+1][j] + cost(i,k,j) )`  
  （k从i遍历到j-1）  

  > 🛠️ **实际操作**：像剥洋葱，从里层（短小组）→外层（大组）计算  

#### 4️⃣ **步骤四：递推顺序（从小组到大组）**  
✅ **必须从最短的区间开始算**（保证依赖值已计算）:  
```python
for 区间长度 L in 2 → 30:          # 先算2人组，再3人组...最后30人组
  for 起点 i in 0 → (30-L):       # 当前小组的起点
    终点 j = i + L - 1           # 当前小组的终点
    for 分割点 k in i → j-1:     # 尝试所有切分方案
        dp[i][j] = max(..., 方案k得分)
```

---

### 🧪 实战训练：三类高频问题
#### ⚖️ **类型1：合并类问题（石子合并）**  
- **cost设计**：合并代价 = 左组总人数×右组总人数  
- **技巧**：用前缀和快速计算人数（`sum[i][j] = S[j]-S[i-1]`）  
  > 例题：[NOI 1995] 石子合并（模板题）

#### 🔤 **类型2：回文类问题（最长回文子序列）**  
- 状态定义：`dp[i][j]` = 字符i到j的最长回文子序列长度  
- **转移逻辑**：  
  - 若两端字符相同：`dp[i][j] = dp[i+1][j-1] + 2`（吸纳两端）  
  - 若不同：`dp[i][j] = max(dp[i+1][j], dp[i][j-1])`（舍弃一端）

#### 🎈 **类型3：操作代价问题（戳气球）**  
- **倒序思维**：考虑最后戳破的气球（引发左中右得分）  
- 状态转移：  
  `dp[i][j] = max( dp[i][k-1] + nums[i-1]*nums[k]*nums[j+1] + dp[k+1][j] )`  
  （k是最后戳破的气球位置）  

---

### 💡 避坑指南（新手常见误区）
1. **忘记初始化**：单点区间（`dp[i][i]`）必须显式赋值！
2. **枚举顺序错**：一定要按 **区间长度→起点→分割点** 顺序循环！
3. **分割点范围**：`k`从`i`到`j-1`，注意左右区间不重叠
4. **特殊边界处理**：对`L=2`的区间常需单独处理

> 📚 **练习路线推荐**：  
> 石子合并 → 矩阵连乘 → 最长回文子序列 → 戳气球

---

## 具体题目：

### 一、[NOI 1995] 石子合并

#### 🔥 问题定义
**输入**：`stones = [4, 1, 3, 2]`（四堆石子，初始合并代价=石子重量）  
**规则**：  
- 每次合并**相邻**两堆，代价=两堆石子总重量之和  
- 求**最小总合并代价**（最终只剩一堆）

> ✅ **DP目标**：计算合并所有石子的最小代价

---

#### 🧠 状态设计与递推方程
```cpp
// dp[i][j] = 合并第i~j堆石子的最小代价
vector<vector<int>> dp(n, vector<int>(n, INT_MAX));

// 前缀和加速（s[i] = stones[0]+...+stones[i-1]）
vector<int> prefix(n+1, 0);
for (int i=1; i<=n; i++) 
    prefix[i] = prefix[i-1] + stones[i-1];
```

##### ⚙️ 状态转移方程：
```cpp
for (int k=i; k<j; k++) {
    dp[i][j] = min(dp[i][j], 
                   dp[i][k] + dp[k+1][j] + 
                   (prefix[j+1]-prefix[i]) // i~j的总重量
                  );
}
```

---

#### 🛠️ C++ 完整代码（含详细注释）
```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int main() {
    vector<int> stones = {4, 1, 3, 2};
    int n = stones.size();
    
    // 1. 初始化DP数组
    vector<vector<int>> dp(n, vector<int>(n, INT_MAX));
    vector<int> prefix(n+1, 0);
    for (int i=0; i<n; i++) {
        dp[i][i] = 0; // 单堆无需合并（代价=0）
        prefix[i+1] = prefix[i] + stones[i]; 
    }
    
    // 2. 枚举区间长度L (从长度为2开始)
    for (int L=2; L<=n; L++) { 
        for (int i=0; i <= n-L; i++) { // 起点i
            int j = i + L - 1;         // 终点j
            
            // 3. 枚举分割点k ∈ [i, j-1]
            for (int k=i; k<j; k++) {
                int total_cost = dp[i][k] + dp[k+1][j] 
                              + (prefix[j+1] - prefix[i]);
                
                // 更新最小代价
                if (total_cost < dp[i][j]) 
                    dp[i][j] = total_cost;
            }
        }
    }
    
    cout << "最小总代价：" << dp[0][n-1] << endl;
    return 0;
}
```

---

### 📝 手推过程（表格展示）
以 `stones = [4, 1, 3, 2]` 为例：

#### 步骤1：初始化单堆（L=1）

| i\j | 0    | 1    | 2    | 3    |
|-----|------|------|------|------|
| **0** | 0    | ∞    | ∞    | ∞    |
| **1** | -    | 0    | ∞    | ∞    |
| **2** | -    | -    | 0    | ∞    |
| **3** | -    | -    | -    | 0    |

#### 步骤2：计算双堆合并（L=2）
- **dp[0][1]** = dp[0][0]+dp[1][1]+(4+1) = 0+0+5 = **5**  
- **dp[1][2]** = 0+0+(1+3)=**4**  
- **dp[2][3]** = 0+0+(3+2)=**5**  

| i\j | 0    | 1    | 2    | 3    |
|-----|------|------|------|------|
| **0** | 0    | 5    | ∞    | ∞    |
| **1** | -    | 0    | 4    | ∞    |
| **2** | -    | -    | 0    | 5    |
| **3** | -    | -    | -    | 0    |

#### 步骤3：计算三堆合并（L=3）
- **dp[0][2]**  
  - k=0: dp[0][0]+dp[1][2] + (4+1+3) = 0+4+8 = **12**  
  - k=1: dp[0][1]+dp[2][2] +8 = 5+0+8 = **13**  
  → min(12,13)=**12**  
- **dp[1][3]**  
  - k=1: dp[1][1]+dp[2][3]+(1+3+2)=0+5+6=**11**  
  - k=2: dp[1][2]+dp[3][3]+6=4+0+6=**10**  
  → min(11,10)=**10**  

| i\j | 0    | 1    | 2    | 3    |
|-----|------|------|------|------|
| **0** | 0    | 5    | 12   | ∞    |
| **1** | -    | 0    | 4    | 10   |
| **2** | -    | -    | 0    | 5    |
| **3** | -    | -    | -    | 0    |

#### 步骤4：计算全局（L=4）
- **dp[0][3]**  
  - k=0: dp[0][0]+dp[1][3] + (4+1+3+2)=0+10+10=**20**  
  - k=1: dp[0][1]+dp[2][3] +10=5+5+10=**20**  
  - k=2: dp[0][2]+dp[3][3] +10=12+0+10=**22**  
  → min(20,20,22)=**20**  

| i\j | 0    | 1    | 2    | 3    |
|-----|------|------|------|------|
| **0** | 0    | 5    | 12   | 20   |
| **1** | -    | 0    | 4    | 10   |
| **2** | -    | -    | 0    | 5    |
| **3** | -    | -    | -    | 0    |

> 💡 **最优策略**：  
> 先合并(1,3)得4 → 堆变为[4,4,2] → 再合并(4,2)得6 → 堆变为[4,6] → 最后合并得10  
> **总代价 = 4(1+3) + 6(4+2) + 10(4+6) = 20**

---

### 🚀 关键优化技巧
1. **前缀和避免重复计算**  
   用 `prefix[j+1]-prefix[i]` 取代遍历求和   
2. **递推方向控制**  
   必须按 `区间长度L从小到大` 计算（代码中三重循环的核心）  
3. **初始化陷阱**  
   单堆代价=0（无需合并），双堆代价=两堆重量和

> 🔍 **复杂度分析**  
> 时间复杂度：O(n³) （三重循环）  
> 空间复杂度：O(n²) （DP矩阵）

---

### 🎯 同类问题拓展（代码框架复用）
1. **矩阵链乘法**：将 `+` 替换为 `*`，代价计算改为行列乘  
2. **多边形三角剖分**：状态转移时考虑多边形顶点权值  
3. **括号最大化**：将代价函数改为匹配分数计算  

---

### 二、最长回文子序列（LeetCode 516）

#### 🎯 问题定义
**输入**：字符串 `s = "bbbab"`  
**输出**：最长回文子序列长度  
**规则**：子序列不要求连续，但需保持相对顺序  
✅ **示例结果**：4（序列 `"bbbb"` 或 `"bab"`）

#### 🧠 DP状态设计
```cpp
// dp[i][j] = 子串 s[i..j] 的最长回文子序列长度
vector<vector<int>> dp(n, vector<int>(n, 0));
```

#### ⚡ 状态转移方程
```cpp
if (s[i] == s[j]) 
    dp[i][j] = dp[i+1][j-1] + 2;  // 两端相同，扩展两端
else 
    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);  // 继承左或右子区间最大值
```

#### 💻 C++ 代码实现
```cpp
int longestPalindromeSubseq(string s) {
    int n = s.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    
    // 初始化：单字符长度为1
    for (int i = 0; i < n; i++) dp[i][i] = 1;

    // 倒序枚举起点i，正序枚举终点j（i<j）
    for (int i = n-1; i >= 0; i--) {
        for (int j = i+1; j < n; j++) {
            if (s[i] == s[j]) 
                dp[i][j] = (j-i==1) ? 2 : dp[i+1][j-1] + 2;
            else 
                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
        }
    }
    return dp[0][n-1];
}
```

#### 🔍 手推实例 `s = "bbbab"`
1. **初始化单字符**：
   - `dp[0][0]=1` (`b`), `dp[1][1]=1` (`b`), `dp[2][2]=1` (`b`), `dp[3][3]=1` (`a`), `dp[4][4]=1` (`b`)

2. **区间 [1,2]（"bb"）**：
   - `s[1]==s[2]` → `dp[1][2] = dp[2][1]+2`
   - 但 `[2,1]` 为空区间（值为0）→ **`dp[1][2]=2`**

3. **区间 [0,3]（"bbba"）**：
   - `s[0]=='b' != s[3]=='a'` → `dp[0][3]=max(dp[1][3], dp[0][2])`
   - 计算 `dp[1][3]`（子串"bba"）:
     * `s[1]=='b' != s[3]=='a'` → `max(dp[2][3], dp[1][2])`
     * `dp[2][3]`（子串"ba"）: `s[2]!=s[3]` → `max(单字符)=1`
     * `dp[1][2]=2` → **`dp[1][3]=2`**
   - `dp[0][2]`（子串"bbb"）: `s[0]==s[2]` → `dp[1][1]+2=1+2=3`
   - ∴ **`dp[0][3]=max(2,3)=3`**

4. **全局 [0,4]（"bbbab"）**：
   - `s[0]=='b' == s[4]=='b'` → `dp[0][4]=dp[1][3]+2=2+2=4`  
   **（最长回文"bbbb"）**

> 💡 **核心洞察**：  
> 当两端字符相同时，直接连接两端字符能构造更长回文序列；否则继承左右子区间的最大值。

---

### 二、戳气球（LeetCode 312）

#### 🎯 问题定义
**输入**：气球数组 `nums = [3, 1, 5, 8]`  
**输出**：最大硬币数（戳破所有气球的累计值）  
**规则**：
- 戳破气球 `i` 获 `nums[i-1] * nums[i] * nums[i+1]` 硬币
- 边界虚拟气球值 `=1`

✅ **示例结果**：167（最优顺序：`1→5→3→8`）

#### 🧠 DP状态设计
```cpp
// dp[i][j] = 戳破开区间(i,j)内所有气球的最大收益
// 新增虚拟边界：nums = [1, 3, 1, 5, 8, 1]
vector<vector<int>> dp(n+2, vector<int>(n+2, 0)); 
```

#### ⚡ 状态转移方程
```cpp
for (int k = i+1; k < j; k++) { // k是最后戳破的气球
    dp[i][j] = max(dp[i][j], 
                  dp[i][k] + dp[k][j] + 
                  nums[i]*nums[k]*nums[j]);
}
```

#### 💻 C++ 代码实现
```cpp
int maxCoins(vector<int>& nums) {
    int n = nums.size();
    vector<int> arr = {1};
    arr.insert(arr.end(), nums.begin(), nums.end());
    arr.push_back(1); // 首尾补1

    vector<vector<int>> dp(n+2, vector<int>(n+2, 0));
    
    for (int len = 3; len <= n+2; len++) { // 开区间长度>=3
        for (int i = 0; i <= n+2-len; i++) {
            int j = i + len - 1;
            for (int k = i+1; k < j; k++) {
                dp[i][j] = max(dp[i][j], 
                              dp[i][k] + dp[k][j] + 
                              arr[i]*arr[k]*arr[j]);
            }
        }
    }
    return dp[0][n+1];
}
```

#### 🔍 手推实例 `nums = [3, 1, 5, 8]`
1. **构建新数组**：  
   `arr = [1, 3, 1, 5, 8, 1]`

2. **计算基础区间（长度3）**：
   - **区间(0,2)**：只含气球`1`（值3）  
     `dp[0][2] = arr[0]*arr[1]*arr[2] = 1*3*1 = 3`
   - **区间(1,3)**：气球`2`（值1）  
     `dp[1][3] = 3*1*5 = 15`
   - **区间(2,4)**：气球`3`（值5）  
     `dp[2][4] = 1*5*8 = 40`
   - **区间(3,5)**：气球`4`（值8）  
     `dp[3][5] = 5*8*1 = 40`

3. **长度4区间：区间(1,4)（气球2,3）**：
   - **最后戳2**：  
     `dp[1][4] = dp[1][2] + dp[2][4] + arr[1]*arr[2]*arr[4] = 0+40+3*1*8=64`
   - **最后戳3**：  
     `dp[1][4] = dp[1][3] + dp[3][4] + arr[1]*arr[3]*arr[4] = 15+0+3*5*8=135`
   - **取最大值**：**`dp[1][4]=135`**

4. **全局区间(0,5)（所有气球）**：
   - **最后戳1（值3）**：  
     `dp[0][5] = dp[0][1]+dp[1][5] + 1*3*1` → 无效（dp[0][1]=0）
   - **最后戳2（值1）**：  
     `dp[0][2]+dp[2][5] + 1*1*1 = 3+dp[2][5]+1`  
     需先算 `dp[2][5]`（子区间(2,5)：气球3,4）:  
     * 最后戳3：`dp[2][4]+dp[4][5]+1*5*1=40+0+5=45`  
     * 最后戳4：`dp[2][3]+dp[3][5]+1*8*1=0+40+8=48`  
     → `dp[2][5]=48`  
     ∴ 总收益 = `3+48+1=52`
   - **最后戳3（值5）**：  
     `dp[0][3]+dp[3][5]+1*5*1`  
     `dp[0][3]`（气球1,2）：  
     * 最后戳1：`dp[0][2]+dp[2][3]+1*3*5=3+0+15=18`  
     * 最后戳2：`dp[0][1]+dp[1][3]+1*1*5=0+15+5=20`  
     → `dp[0][3]=20`  
     ∴ 总收益 = `20+40+5=65`
   - **最后戳4（值8）**：  
     `dp[0][4]+dp[4][5] + 1*8*1`  
     `dp[0][4]`（气球1,2,3）：  
     * 最后戳1：`dp[0][2]+dp[2][4]+1*3*8=3+40+24=67`  
     * 最后戳2：`dp[0][1]+dp[1][4]+1*1*8=0+135+8=143`  
     * 最后戳3：`dp[0][3]+dp[3][4]+1*5*8=20+0+40=60`  
     → `dp[0][4]=143`  
     ∴ 总收益 = `143+0+8=151`
   - **最大值在最后戳4时取得** → **`151`？**  
     ❗ 更正：实际最优是 **最后戳4时**：  
     `dp[0][4]` 需重新计算：  
     * 最后戳1：`dp[0][1]+dp[1][4] +1*3*8 =0+135+24=159`  
     * 最后戳2：`dp[0][2]+dp[2][4] +1*1*8=3+40+8=51`  
     * 最后戳3：`dp[0][3]+dp[3][4] +1*5*8=20+0+40=60`  
     → `dp[0][4]=159`  
     ∴ 总收益 = `159 + dp[4][5]（空）+ 1*8*1=159+0+8=167`

> 💡 **关键思维**：  
> 逆向思维——确定**最后戳破的气球**，将其收益作为分割点，将问题分解为左右两个独立子区间。

---

### ✨ 区间DP核心技巧总结
1. **状态设计铁律**：  
   `dp[i][j]` 表示区间 `[i, j]` 的解，需明确定义边界含义
2. **转移方程方向**：  
   - 由小区间 → 大区间（长度从小到大枚举）  
   - 依赖方向：`dp[i][j]` 依赖 `dp[i][k]` 和 `dp[k][j]`（k为分割点）
3. **初始化技巧**：  
   - 单元素区间直接赋值（回文序列=1，戳气球=0）  
   - 无效区间（i>j）默认值=0
4. **时间复杂度**：O(n³)  
   可通过平行四边形优化（特殊题型）降至O(n²)
